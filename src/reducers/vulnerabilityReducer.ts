import { Vulnerability } from '../types/vulnerability';
import { VulnerabilityState as VulnState } from '../types/constants';

interface State {
  vulnerabilities: Vulnerability[];
  filteredVulnerabilities: Vulnerability[];
  filters: {
    status: VulnState | '';
    criticality: string;
    search: string;
  };
}

const initialFilters: State['filters'] = {
  status: '',
  criticality: '',
  search: ''
};

export type VulnerabilityAction =
  | { type: 'SET_VULNERABILITIES'; payload: Vulnerability[] }
  | { type: 'ADD_VULNERABILITY'; payload: Vulnerability }
  | { type: 'UPDATE_VULNERABILITY'; payload: Vulnerability }
  | { type: 'DELETE_VULNERABILITY'; payload: Vulnerability }  | { type: 'UPDATE_STATUS'; payload: { vulnerability: Vulnerability; status: VulnState } }
  | { type: 'SET_FILTER'; payload: { key: keyof State['filters']; value: string } }
  | { type: 'CLEAR_FILTERS' };

function applyFilters(vulnerabilities: Vulnerability[], filters: State['filters']): Vulnerability[] {
  return vulnerabilities.filter(vuln => {
    const matchesStatus = !filters.status || vuln.status === filters.status;
    const matchesCriticality = !filters.criticality || vuln.criticality === filters.criticality;
    const matchesSearch = !filters.search || 
      vuln.title.toLowerCase().includes(filters.search.toLowerCase()) ||
      vuln.description.toLowerCase().includes(filters.search.toLowerCase());
    
    return matchesStatus && matchesCriticality && matchesSearch;
  });
}

export default function vulnerabilityReducer(state: State, action: VulnerabilityAction): State {
  let updatedVulnerabilities: Vulnerability[];

  switch (action.type) {
    case 'SET_VULNERABILITIES':
      return {
        ...state,
        vulnerabilities: action.payload,
        filteredVulnerabilities: applyFilters(action.payload, state.filters)
      };

    case 'ADD_VULNERABILITY':
      updatedVulnerabilities = [...state.vulnerabilities, action.payload];
      return {
        ...state,
        vulnerabilities: updatedVulnerabilities,
        filteredVulnerabilities: applyFilters(updatedVulnerabilities, state.filters)
      };

    case 'UPDATE_VULNERABILITY':
      updatedVulnerabilities = state.vulnerabilities.map(vuln =>
        vuln.id === action.payload.id ? action.payload : vuln
      );
      return {
        ...state,
        vulnerabilities: updatedVulnerabilities,
        filteredVulnerabilities: applyFilters(updatedVulnerabilities, state.filters)
      };

    case 'DELETE_VULNERABILITY':
      updatedVulnerabilities = state.vulnerabilities.filter(vuln => 
        vuln.id !== action.payload.id
      );
      return {
        ...state,
        vulnerabilities: updatedVulnerabilities,
        filteredVulnerabilities: applyFilters(updatedVulnerabilities, state.filters)
      };

    case 'UPDATE_STATUS':
      updatedVulnerabilities = state.vulnerabilities.map(vuln =>
        vuln.id === action.payload.vulnerability.id
          ? { ...vuln, status: action.payload.status }
          : vuln
      );
      return {
        ...state,
        vulnerabilities: updatedVulnerabilities,
        filteredVulnerabilities: applyFilters(updatedVulnerabilities, state.filters)
      };

    case 'SET_FILTER':
      const newFilters = {
        ...state.filters,
        [action.payload.key]: action.payload.value
      };
      return {
        ...state,
        filters: newFilters,
        filteredVulnerabilities: applyFilters(state.vulnerabilities, newFilters)
      };

    case 'CLEAR_FILTERS':
      return {
        ...state,
        filters: initialFilters,
        filteredVulnerabilities: state.vulnerabilities
      };

    default:
      return state;
  }
}
