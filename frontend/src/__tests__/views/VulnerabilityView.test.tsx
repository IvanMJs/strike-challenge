import React from 'react';
import { render, screen, fireEvent, waitFor, within, act } from '@testing-library/react';
import { vi, describe, it, expect, beforeEach } from 'vitest';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import { VulnerabilityView } from '../../views/VulnerabilityView';
import * as AuthContext from '../../context/AuthContext';
import * as VulnerabilityContext from '../../context/VulnerabilityContext';
import * as vulnerabilityService from '../../services/vulnerabilityService';
import { Vulnerability } from '../../types/vulnerability';
import { VulnerabilityCriticality, VulnerabilityState } from '../../types/constants';
import { STATES } from '../../utils/constants';

vi.mock('../../context/AuthContext', () => ({
  useAuth: vi.fn()
}));

vi.mock('../../context/VulnerabilityContext', () => ({
  useVulnerabilities: vi.fn()
}));

vi.mock('../../services/vulnerabilityService', () => ({
  fetchVulnerabilities: vi.fn(),
  createVulnerability: vi.fn(),
  updateVulnerability: vi.fn(),
  deleteVulnerability: vi.fn()
}));

describe('VulnerabilityView', () => {
  const mockVulnerabilities: Vulnerability[] = [
    {
      id: 1,
      title: 'Test Vulnerability',
      description: 'Test Description',
      criticality: 'High' as VulnerabilityCriticality,
      status: 'Pending' as VulnerabilityState,
      cwe: 'CWE-79',
      suggestedFix: 'Fix it'
    }
  ];

  const mockDispatch = vi.fn();
  const mockFilters = {
    status: '',
    criticality: '',
    search: ''
  };

  beforeEach(() => {
    vi.clearAllMocks();
    (AuthContext.useAuth as any).mockReturnValue({ isAdmin: true });
    (VulnerabilityContext.useVulnerabilities as any).mockReturnValue({
      vulnerabilities: mockVulnerabilities,
      filteredVulnerabilities: mockVulnerabilities,
      filters: mockFilters,
      dispatch: mockDispatch,
      loading: false,
      error: null
    });
    (vulnerabilityService.fetchVulnerabilities as any).mockResolvedValue(mockVulnerabilities);
  });

  const fillFormWithValidData = async (form: HTMLElement, data: any = {}) => {
    const defaultData = {      title: 'Test Title',
      description: 'Test Description',
      criticality: 'High',
      cwe: 'CWE-79',
      suggestedFix: 'Test Fix',
      status: 'Pending Fix',
      ...data
    };

    const titleInput = within(form).getByLabelText('Title');
    const descInput = within(form).getByLabelText('Description');
    const criticalitySelect = within(form).getByLabelText('Criticality');
    const cweSelect = within(form).getByLabelText('CWE');
    const suggestedFixInput = within(form).getByLabelText('Suggested Fix');
    const statusSelect = within(form).getByLabelText('Status');
      fireEvent.change(titleInput, { target: { name: 'title', value: defaultData.title } });
    fireEvent.blur(titleInput);
    
    fireEvent.change(descInput, { target: { name: 'description', value: defaultData.description } });
    fireEvent.blur(descInput);
    
    fireEvent.change(criticalitySelect, { target: { name: 'criticality', value: defaultData.criticality } });
    fireEvent.blur(criticalitySelect);
    
    fireEvent.change(cweSelect, { target: { name: 'cwe', value: defaultData.cwe } });
    fireEvent.blur(cweSelect);
    
    fireEvent.change(suggestedFixInput, { target: { name: 'suggestedFix', value: defaultData.suggestedFix } });
    fireEvent.blur(suggestedFixInput);
    
    fireEvent.change(statusSelect, { target: { name: 'status', value: defaultData.status } });
    fireEvent.blur(statusSelect);
  };

  it('loads and displays vulnerabilities', async () => {
    render(<VulnerabilityView />);
    
    expect(screen.getByText('Loading vulnerabilities...')).toBeInTheDocument();
    
    await waitFor(() => {
      expect(vulnerabilityService.fetchVulnerabilities).toHaveBeenCalled();
      expect(mockDispatch).toHaveBeenCalledWith({
        type: 'SET_VULNERABILITIES',
        payload: mockVulnerabilities
      });
    });
  });

  it('handles vulnerability creation', async () => {    const newVulnerability = {
      title: 'New Vulnerability',
      description: 'New Description',
      criticality: 'High' as VulnerabilityCriticality,
      cwe: 'CWE-89',
      suggestedFix: 'Fix it properly',
      status: 'Pending Fix' as VulnerabilityState
    };

    (vulnerabilityService.createVulnerability as any).mockResolvedValue({
      id: 2,
      ...newVulnerability
    });

    render(<VulnerabilityView />);

    const form = await screen.findByRole('form', { name: 'vulnerability-form' });
    await fillFormWithValidData(form, newVulnerability);
    
    // Submit the form
    fireEvent.submit(form);

    await waitFor(() => {
      expect(vulnerabilityService.createVulnerability).toHaveBeenCalledWith(newVulnerability);
      expect(mockDispatch).toHaveBeenCalledWith({
        type: 'ADD_VULNERABILITY',
        payload: { id: 2, ...newVulnerability }
      });
    });
  });

  it('handles edit mode correctly', async () => {
    render(<VulnerabilityView />);
    
    const editButton = await screen.findByRole('button', { name: /edit/i });
    fireEvent.click(editButton);

    await waitFor(() => {
      expect((screen.getByLabelText('Title') as HTMLInputElement).value).toBe(mockVulnerabilities[0].title);
      expect((screen.getByLabelText('Description') as HTMLInputElement).value).toBe(mockVulnerabilities[0].description);
      expect((screen.getByLabelText('CWE') as HTMLInputElement).value).toBe(mockVulnerabilities[0].cwe);
    });
  });

  it('prevents non-admin users from editing', async () => {
    (AuthContext.useAuth as any).mockReturnValue({ isAdmin: false });
    render(<VulnerabilityView />);

    await waitFor(() => {
      expect(screen.queryByText('Loading vulnerabilities...')).not.toBeInTheDocument();
    });
    expect(screen.queryByRole('button', { name: /edit/i })).not.toBeInTheDocument();
    expect(screen.queryByRole('button', { name: /delete/i })).not.toBeInTheDocument();
  });
  it('handles delete functionality', async () => {
    (vulnerabilityService.deleteVulnerability as any).mockResolvedValue({});
    render(<VulnerabilityView />);

    await waitFor(() => {
      expect(screen.queryByText('Loading vulnerabilities...')).not.toBeInTheDocument();
    });

    const deleteButton = await screen.findByRole('button', { name: /delete/i });
    fireEvent.click(deleteButton);    // Find and click Yes in the confirmation dialog
    const confirmButton = await screen.findByRole('button', { name: /yes/i });
    fireEvent.click(confirmButton);

    await waitFor(() => {
      expect(vulnerabilityService.deleteVulnerability).toHaveBeenCalledWith(mockVulnerabilities[0].id);
      expect(mockDispatch).toHaveBeenCalledWith({
        type: 'DELETE_VULNERABILITY',
        payload: mockVulnerabilities[0].id
      });
    });
  });

  it('handles errors during vulnerability fetch', async () => {
    const error = new Error('Failed to fetch vulnerabilities');
    (vulnerabilityService.fetchVulnerabilities as any).mockRejectedValue(error);
    
    (VulnerabilityContext.useVulnerabilities as any).mockReturnValue({
      ...VulnerabilityContext.useVulnerabilities(),
      loading: false,
      error: 'Failed to fetch vulnerabilities'
    });

    render(<VulnerabilityView />);
    expect(await screen.findByText('Failed to fetch vulnerabilities')).toBeInTheDocument();
  });
  it('handles errors during vulnerability creation', async () => {
    const error = new Error('Failed to create vulnerability');
    (vulnerabilityService.createVulnerability as any).mockRejectedValue(error);

    render(<VulnerabilityView />);
    
    const form = await screen.findByRole('form', { name: 'vulnerability-form' });
    
    const formData = {
      title: 'Test Title',
      description: 'Test Description',
      criticality: 'High',
      cwe: 'CWE-79',
      suggestedFix: 'Test Fix',
      status: 'Pending Fix'  
    };

    const titleInput = within(form).getByLabelText('Title');
    const descInput = within(form).getByLabelText('Description');
    const criticalitySelect = within(form).getByLabelText('Criticality');
    const cweSelect = within(form).getByLabelText('CWE');
    const suggestedFixInput = within(form).getByLabelText('Suggested Fix');
    const statusSelect = within(form).getByLabelText('Status');

    // Fill out the form
    fireEvent.change(titleInput, { target: { name: 'title', value: formData.title } });
    fireEvent.blur(titleInput);
    
    fireEvent.change(descInput, { target: { name: 'description', value: formData.description } });
    fireEvent.blur(descInput);
    
    fireEvent.change(criticalitySelect, { target: { name: 'criticality', value: formData.criticality } });
    fireEvent.blur(criticalitySelect);
    
    fireEvent.change(cweSelect, { target: { name: 'cwe', value: formData.cwe } });
    fireEvent.blur(cweSelect);
    
    fireEvent.change(suggestedFixInput, { target: { name: 'suggestedFix', value: formData.suggestedFix } });
    fireEvent.blur(suggestedFixInput);
    
    fireEvent.change(statusSelect, { target: { name: 'status', value: formData.status } });
    fireEvent.blur(statusSelect);
    
    fireEvent.submit(form);

    await waitFor(() => {
      expect(vulnerabilityService.createVulnerability).toHaveBeenCalledWith(formData);
    });

    expect(await screen.findByText('Failed to create vulnerability')).toBeInTheDocument();
  });

  it('handles status changes', async () => {
    const updatedVulnerability = {
      ...mockVulnerabilities[0],
      status: 'Solved' as VulnerabilityState
    };

    (vulnerabilityService.updateVulnerability as any).mockResolvedValue(updatedVulnerability);

    render(<VulnerabilityView />);
    
    // Wait for the grid to load and find status select
    await waitFor(() => {
      expect(screen.queryByText('Loading vulnerabilities...')).not.toBeInTheDocument();
    });

    const statusSelect = await screen.findByRole('combobox', { name: 'Change Status' });
    fireEvent.change(statusSelect, { target: { value: 'Solved' } });

    await waitFor(() => {
      expect(vulnerabilityService.updateVulnerability).toHaveBeenCalledWith(
        mockVulnerabilities[0].id.toString(),
        expect.objectContaining({ status: 'Solved' })
      );
      expect(mockDispatch).toHaveBeenCalledWith({
        type: 'UPDATE_VULNERABILITY',
        payload: updatedVulnerability
      });
    });
  });
});
