import { describe, it, expect } from 'vitest';
import { vulnerabilityReducer, initialState, VulnerabilityState } from '../../reducers/vulnerabilityReducer';
import { Vulnerability } from '../../types/vulnerability';

describe('vulnerabilityReducer', () => {
  const mockVulnerability: Vulnerability = {
    id: 1,
    title: 'Test Vulnerability',
    description: 'Test Description',    criticality: 'High',
    cwe: 'CWE-79',
    suggestedFix: 'Fix it',
    status: 'Pending Fix'
  };

  const mockVulnerability2: Vulnerability = {
    id: 2,
    title: 'Another Vulnerability',
    description: 'Another Description',    criticality: 'Medium',
    cwe: 'CWE-89',
    suggestedFix: 'Fix it too',
    status: 'In Progress'
  };

  it('should return initial state', () => {
    expect(vulnerabilityReducer(initialState, {} as any)).toEqual(initialState);
  });

  it('should handle SET_VULNERABILITIES', () => {
    const vulnerabilities = [mockVulnerability, mockVulnerability2];
    const action = {
      type: 'SET_VULNERABILITIES' as const,
      payload: vulnerabilities
    };

    const newState = vulnerabilityReducer(initialState, action);

    expect(newState).toEqual({
      ...initialState,
      vulnerabilities,
      loading: false,
      error: null
    });
  });

  it('should handle ADD_VULNERABILITY', () => {
    const action = {
      type: 'ADD_VULNERABILITY' as const,
      payload: mockVulnerability
    };

    const newState = vulnerabilityReducer(initialState, action);

    expect(newState).toEqual({
      ...initialState,
      vulnerabilities: [mockVulnerability],
      loading: false,
      error: null
    });
  });

  it('should handle UPDATE_VULNERABILITY', () => {
    const initialStateWithVulns = {
      ...initialState,
      vulnerabilities: [mockVulnerability, mockVulnerability2]
    };

    const updatedVulnerability = {
      ...mockVulnerability,
      title: 'Updated Title'
    };

    const action = {
      type: 'UPDATE_VULNERABILITY' as const,
      payload: updatedVulnerability
    };

    const newState = vulnerabilityReducer(initialStateWithVulns, action);

    expect(newState.vulnerabilities).toHaveLength(2);
    expect(newState.vulnerabilities.find(v => v.id === 1)?.title).toBe('Updated Title');
    expect(newState.vulnerabilities.find(v => v.id === 2)).toEqual(mockVulnerability2);
  });

  it('should handle DELETE_VULNERABILITY', () => {
    const initialStateWithVulns = {
      ...initialState,
      vulnerabilities: [mockVulnerability, mockVulnerability2]
    };

    const action = {
      type: 'DELETE_VULNERABILITY' as const,
      payload: mockVulnerability.id
    };

    const newState = vulnerabilityReducer(initialStateWithVulns, action);

    expect(newState.vulnerabilities).toHaveLength(1);
    expect(newState.vulnerabilities[0]).toEqual(mockVulnerability2);
  });

  it('should handle SET_LOADING', () => {
    const action = {
      type: 'SET_LOADING' as const,
      payload: true
    };

    const newState = vulnerabilityReducer(initialState, action);

    expect(newState).toEqual({
      ...initialState,
      loading: true,
      error: null
    });
  });

  it('should handle SET_ERROR', () => {
    const error = 'Test error message';
    const action = {
      type: 'SET_ERROR' as const,
      payload: error
    };

    const newState = vulnerabilityReducer(initialState, action);

    expect(newState).toEqual({
      ...initialState,
      error,
      loading: false
    });
  });

  it('should handle SET_FILTER', () => {
    const actions = [
      {
        type: 'SET_FILTER' as const,
        payload: { key: 'status' as const, value: 'open' }
      },
      {
        type: 'SET_FILTER' as const,
        payload: { key: 'criticality' as const, value: 'high' }
      },
      {
        type: 'SET_FILTER' as const,
        payload: { key: 'search' as const, value: 'test' }
      }
    ];

    let state = initialState;
    for (const action of actions) {
      state = vulnerabilityReducer(state, action);
    }

    expect(state.filters).toEqual({
      status: 'open',
      criticality: 'high',
      search: 'test'
    });
  });

  it('should handle CLEAR_FILTERS', () => {
    const stateWithFilters: VulnerabilityState = {
      ...initialState,      filters: {
        status: 'Pending Fix',
        criticality: 'High',
        search: 'test'
      }
    };

    const action = {
      type: 'CLEAR_FILTERS' as const
    };

    const newState = vulnerabilityReducer(stateWithFilters, action);

    expect(newState.filters).toEqual(initialState.filters);
  });
});
