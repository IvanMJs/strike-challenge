import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import VulnerabilityCard from '../../../components/vulnerabilityCard/VulnerabilityCard';
import type { Vulnerability } from '../../../types/vulnerability';
import { STATES } from '../../../utils/constants';
import type { VulnerabilityState } from '../../../types/constants';

const mockIsAdmin = vi.fn(() => false);

vi.mock('../../../context/AuthContext', () => ({
  useAuth: () => ({ isAdmin: mockIsAdmin() }),
}));

describe('VulnerabilityCard', () => {
  const mockVuln: Vulnerability = {
    id: '1',
    title: 'Test Vulnerability',
    description: 'Test Description',
    criticality: 'High',
    status: 'Pending Fix',
    cwe: 'CWE-79',
    suggestedFix: 'Fix the test vulnerability',
  };

  const mockOnEdit = vi.fn();
  const mockOnDelete = vi.fn();
  const mockOnStatusChange = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    mockIsAdmin.mockClear();
  });

  it('renders vulnerability information correctly', () => {
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    expect(screen.getByText(mockVuln.title)).toBeInTheDocument();
    expect(screen.getByText(mockVuln.description)).toBeInTheDocument();
    expect(screen.getByText(mockVuln.criticality)).toBeInTheDocument();
    expect(screen.getByText(mockVuln.status)).toBeInTheDocument();
  });

  it('renders edit and delete buttons for admin users', () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    expect(screen.getByRole('button', { name: /edit/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /delete/i })).toBeInTheDocument();
  });

  it('hides edit and delete buttons for non-admin users', () => {
    mockIsAdmin.mockReturnValue(false);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    expect(screen.queryByRole('button', { name: /edit/i })).not.toBeInTheDocument();
    expect(screen.queryByRole('button', { name: /delete/i })).not.toBeInTheDocument();
  });

  it('calls onEdit when edit button is clicked', () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    const editButton = screen.getByRole('button', { name: /edit/i });
    fireEvent.click(editButton);

    expect(mockOnEdit).toHaveBeenCalledWith(mockVuln);
  });

  it('shows confirm dialog before deleting', async () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    const deleteButton = screen.getByRole('button', { name: /delete/i });
    fireEvent.click(deleteButton);

    expect(screen.getByText(/Are you sure/i)).toBeInTheDocument();    // Confirm deletion
    const confirmButton = screen.getByRole('button', { name: /yes/i });
    fireEvent.click(confirmButton);

    expect(mockOnDelete).toHaveBeenCalledWith(mockVuln);
  });

  it('calls onStatusChange when status is changed', () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    const statusSelect = screen.getByRole('combobox');
    fireEvent.change(statusSelect, { target: { value: 'In Progress' } });

    expect(mockOnStatusChange).toHaveBeenCalledWith(mockVuln, 'In Progress');
  });

  it('displays vulnerability history when available', () => {
    const vulnWithHistory = {
      ...mockVuln,
      history: [
        {
          from: 'Pending Fix' as VulnerabilityState,
          to: 'In Progress' as VulnerabilityState,
          at: '2025-06-16T10:00:00Z',
        },
      ],
    };

    render(
      <VulnerabilityCard
        vuln={vulnWithHistory}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    expect(screen.getByText(/Pending Fix.*In Progress/i)).toBeInTheDocument();
  });
});
