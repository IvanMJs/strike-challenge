import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import VulnerabilityCard from '../../../components/vulnerabilityCard/VulnerabilityCard';
import type { Vulnerability } from '../../../types/vulnerability';
import { STATES } from '../../../utils/constants';
import type { VulnerabilityState } from '../../../types/constants';

const mockIsAdmin = vi.fn(() => false);

vi.mock('../../../context/AuthContext', () => ({
  useAuth: () => ({ isAdmin: mockIsAdmin() }),
}));

describe('VulnerabilityCard', () => {
  const mockVuln: Vulnerability = {
    id: '1',
    title: 'Test Vulnerability',
    description: 'Test Description',
    criticality: 'High',
    status: 'Pending Fix',
    cwe: 'CWE-79',
    suggestedFix: 'Fix the test vulnerability',
    createdAt: '2025-06-16T12:00:00Z',
  };

  const mockOnEdit = vi.fn();
  const mockOnDelete = vi.fn();
  const mockOnStatusChange = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    mockIsAdmin.mockClear();
  });

  it('renders vulnerability information correctly', () => {
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    expect(screen.getByText(mockVuln.title)).toBeInTheDocument();
    expect(screen.getByText(mockVuln.description)).toBeInTheDocument();
    expect(screen.getByText(mockVuln.criticality)).toBeInTheDocument();
    expect(screen.getByText(mockVuln.status)).toBeInTheDocument();
  });

  it('renders edit and delete buttons for admin users', () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    expect(screen.getByRole('button', { name: /edit/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /delete/i })).toBeInTheDocument();
  });

  it('hides edit and delete buttons for non-admin users', () => {
    mockIsAdmin.mockReturnValue(false);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    expect(screen.queryByRole('button', { name: /edit/i })).not.toBeInTheDocument();
    expect(screen.queryByRole('button', { name: /delete/i })).not.toBeInTheDocument();
  });  it('shows edit modal and calls onEdit when changes are saved', async () => {
    mockIsAdmin.mockReturnValue(true);

    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />,
      { 
        container: document.body // This ensures the portal works in tests
      }
    );

    // Open the modal
    const editButton = screen.getByRole('button', { name: /edit/i });
    fireEvent.click(editButton);

    // Wait for the modal to be visible
    await waitFor(() => {
      expect(screen.getByText('Edit Vulnerability')).toBeInTheDocument();
    });

    // Make changes
    const titleInput = screen.getByLabelText(/title/i);
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });

    // Submit the form
    const saveButton = screen.getByRole('button', { name: /save changes/i });
    fireEvent.click(saveButton);

    // Verify onEdit was called with the updated vulnerability
    await waitFor(() => {
      expect(mockOnEdit).toHaveBeenCalledWith(expect.objectContaining({
        ...mockVuln,
        title: 'Updated Title',
        history: expect.any(Array)
      }));
    });
  });

  it('shows confirm dialog before deleting', async () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    const deleteButton = screen.getByRole('button', { name: /delete/i });
    fireEvent.click(deleteButton);

    expect(screen.getByText(/Are you sure/i)).toBeInTheDocument();    // Confirm deletion
    const confirmButton = screen.getByRole('button', { name: /yes/i });
    fireEvent.click(confirmButton);

    expect(mockOnDelete).toHaveBeenCalledWith(mockVuln);
  });

  it('calls onStatusChange when status is changed', () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    const statusSelect = screen.getByRole('combobox');
    fireEvent.change(statusSelect, { target: { value: 'In Progress' } });

    expect(mockOnStatusChange).toHaveBeenCalledWith(mockVuln, 'In Progress');
  });

  it('displays vulnerability history when available', () => {
    const vulnWithHistory = {
      ...mockVuln,
      history: [
        {
          at: '2025-06-16T10:00:00Z',
          changes: [{
            field: 'status',
            from: 'Pending Fix',
            to: 'In Progress'
          }]
        },
      ],
    };

    render(
      <VulnerabilityCard
        vuln={vulnWithHistory}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    expect(screen.getByText(/Pending Fix.*In Progress/i)).toBeInTheDocument();
  });

  it('opens edit modal when edit button is clicked', () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    const editButton = screen.getByRole('button', { name: /edit/i });
    fireEvent.click(editButton);

    expect(screen.getByText('Edit Vulnerability')).toBeInTheDocument();
    expect(screen.getByLabelText('Title')).toHaveValue(mockVuln.title);
    expect(screen.getByLabelText('Description')).toHaveValue(mockVuln.description);
  });

  it('updates vulnerability when save changes is clicked in modal', async () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    // Open modal
    fireEvent.click(screen.getByRole('button', { name: /edit/i }));

    // Update title
    const titleInput = screen.getByLabelText('Title');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });

    // Save changes
    const saveButton = screen.getByRole('button', { name: /save changes/i });
    fireEvent.click(saveButton);

    expect(mockOnEdit).toHaveBeenCalledWith(expect.objectContaining({
      ...mockVuln,
      title: 'Updated Title',
    }));
  });

  it('closes modal without saving when cancel is clicked', () => {
    mockIsAdmin.mockReturnValue(true);
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    // Open modal
    fireEvent.click(screen.getByRole('button', { name: /edit/i }));

    // Update title
    const titleInput = screen.getByLabelText('Title');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });

    // Click cancel
    fireEvent.click(screen.getByRole('button', { name: /cancel/i }));

    // Modal should be closed
    expect(screen.queryByText('Edit Vulnerability')).not.toBeInTheDocument();
    // onEdit should not have been called
    expect(mockOnEdit).not.toHaveBeenCalled();
  });

  it('formats dates in a user-friendly way', () => {
    render(
      <VulnerabilityCard
        vuln={mockVuln}
        STATES={STATES}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
        onStatusChange={mockOnStatusChange}
      />
    );

    // Check if the date is formatted correctly (Jun 16, 2025 12:00 PM)
    expect(screen.getByText(/Jun 16, 2025/)).toBeInTheDocument();
  });
});
