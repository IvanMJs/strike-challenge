import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  fetchVulnerabilities,
  createVulnerability,
  updateVulnerability,
  deleteVulnerability,
} from '../../../services/vulnerabilityService';
import type { Mock } from 'vitest';
import type { VulnerabilityCreate, Vulnerability } from '../../../types/vulnerability';
import type { VulnerabilityState, VulnerabilityCriticality } from '../../../types/constants';

const API_URL = 'http://localhost:3000';

const mockLocalStorage = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
};
Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage,
});

const mockFetch = vi.fn();
global.fetch = mockFetch;

describe('vulnerabilityService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockFetch.mockReset();
    mockLocalStorage.getItem.mockReturnValue('test-token');
  });

  const mockHeaders = {
    'Authorization': 'Bearer test-token',
    'Content-Type': 'application/json',
  };

  describe('fetchVulnerabilities', () => {
    it('should fetch vulnerabilities successfully', async () => {
      const mockVulnerabilities = [
        {
          id: 1,
          title: 'Test Vulnerability',
          description: 'Test Description',
          criticality: 'high',
          status: 'open',
          cwe: 'CWE-79',
        },
      ];

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockVulnerabilities),
      });

      const result = await fetchVulnerabilities();

      expect(mockFetch).toHaveBeenCalledWith(`${API_URL}/api/vulnerabilities`, {
        headers: mockHeaders,
      });
      expect(result).toEqual(mockVulnerabilities);
    });

    it('should handle fetch failure', async () => {
      const errorMessage = 'Failed to fetch vulnerabilities';
      mockFetch.mockResolvedValueOnce({
        ok: false,
        json: () => Promise.resolve({ error: errorMessage }),
      });

      await expect(fetchVulnerabilities()).rejects.toThrow(errorMessage);
    });

    it('should handle network errors', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Network error'));

      await expect(fetchVulnerabilities()).rejects.toThrow();
    });

    it('should handle missing token', async () => {
      mockLocalStorage.getItem.mockReturnValueOnce(null);

      await expect(fetchVulnerabilities()).rejects.toThrow('No authentication token found');
    });
  });

  describe('createVulnerability', () => {    const newVulnerability: VulnerabilityCreate = {
      title: 'New Vulnerability',
      description: 'New Description',
      criticality: 'medium' as VulnerabilityCriticality,
      status: 'open' as VulnerabilityState,
      cwe: 'CWE-89',
    };

    it('should create vulnerability successfully', async () => {
      const mockCreatedVulnerability = { id: 1, ...newVulnerability };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockCreatedVulnerability),
      });

      const result = await createVulnerability(newVulnerability);

      expect(mockFetch).toHaveBeenCalledWith(`${API_URL}/api/vulnerabilities`, {
        method: 'POST',
        headers: mockHeaders,
        body: JSON.stringify(newVulnerability),
      });
      expect(result).toEqual(mockCreatedVulnerability);
    });

    it('should handle creation failure', async () => {
      const errorMessage = 'Failed to create vulnerability';
      mockFetch.mockResolvedValueOnce({
        ok: false,
        json: () => Promise.resolve({ error: errorMessage }),
      });

      await expect(createVulnerability(newVulnerability)).rejects.toThrow(errorMessage);
    });
  });

  describe('updateVulnerability', () => {    const updateData: Partial<Vulnerability> = {
      title: 'Updated Title',
      status: 'closed' as VulnerabilityState,
    };

    it('should update vulnerability successfully', async () => {
      const mockUpdatedVulnerability = { id: 1, ...updateData };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockUpdatedVulnerability),
      });

      const result = await updateVulnerability(1, updateData);

      expect(mockFetch).toHaveBeenCalledWith(`${API_URL}/api/vulnerabilities/1`, {
        method: 'PUT',
        headers: mockHeaders,
        body: JSON.stringify(updateData),
      });
      expect(result).toEqual(mockUpdatedVulnerability);
    });

    it('should handle update failure', async () => {
      const errorMessage = 'Failed to update vulnerability';
      mockFetch.mockResolvedValueOnce({
        ok: false,
        json: () => Promise.resolve({ error: errorMessage }),
      });

      await expect(updateVulnerability(1, updateData)).rejects.toThrow(errorMessage);
    });

    it('should handle invalid ID format', async () => {
      await expect(updateVulnerability('invalid-id', updateData)).rejects.toThrow('Invalid ID format');
    });
  });

  describe('deleteVulnerability', () => {
    it('should delete vulnerability successfully', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({}),
      });

      await deleteVulnerability(1);

      expect(mockFetch).toHaveBeenCalledWith(`${API_URL}/api/vulnerabilities/1`, {
        method: 'DELETE',
        headers: {
          'Authorization': 'Bearer test-token',
        },
      });
    });

    it('should handle delete failure', async () => {
      const errorMessage = 'Failed to delete vulnerability';
      mockFetch.mockResolvedValueOnce({
        ok: false,
        json: () => Promise.resolve({ error: errorMessage }),
      });

      await expect(deleteVulnerability(1)).rejects.toThrow();
    });

    it('should handle invalid ID format', async () => {
      await expect(deleteVulnerability('invalid-id')).rejects.toThrow('Invalid ID format');
    });    it('should handle missing token', async () => {
      (localStorage.getItem as Mock).mockReturnValue(null);

      await expect(deleteVulnerability(1)).rejects.toThrow();
    });
  });
});
