import React, { useEffect, useState } from 'react';
import VulnerabilityForm from '../components/vulnerabilityForm/VulnerabilityForm';
import VulnerabilityGrid from '../components/vulnerabilityGrid/VulnerabilityGrid';
import FiltersBar from '../components/filterBar/FiltersBar';
import { useAuth } from '../context/AuthContext';
import { useVulnerabilities } from '../context/VulnerabilityContext';
import { STATES, CRITICALITY_OPTIONS } from '../utils/constants';
import type { VulnerabilityState, VulnerabilityCriticality } from '../types/constants';
import type { Vulnerability, VulnerabilityCreate } from '../types/vulnerability';
import { createVulnerability, deleteVulnerability, fetchVulnerabilities, updateVulnerability } from '../services/vulnerabilityService';

const initialForm: VulnerabilityCreate = {
  title: '',
  description: '',
  criticality: 'Medium',
  cwe: '',
  suggestedFix: '',
  status: 'Pending Fix',
};

export function VulnerabilityView() {
  const { dispatch, filteredVulnerabilities } = useVulnerabilities();
  const { isAdmin } = useAuth();
  const [editingId, setEditingId] = useState<string | null>(null);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [form, setForm] = useState<VulnerabilityCreate>(initialForm);

  useEffect(() => {
    loadVulnerabilities();
  }, []);

  async function loadVulnerabilities() {
    setIsLoading(true);
    try {
      const vulns = await fetchVulnerabilities();
      dispatch({ type: 'SET_VULNERABILITIES', payload: vulns });
    } catch (err) {
      setError('Failed to fetch vulnerabilities');
      console.error('Error fetching vulnerabilities:', err);
    } finally {
      setIsLoading(false);
    }
  }

  function handleChange(e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) {
    const value = e.target.value;
    const name = e.target.name;
    
    setForm((prev: VulnerabilityCreate) => ({
      ...prev,
      [name]: value
    }));
  }

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError('');
    try {
      if (editingId) {
        if (!isAdmin) {
          setError('You do not have permission to edit vulnerabilities');
          return;
        }
        const updatedVuln = await updateVulnerability(editingId, form);
        dispatch({ type: 'UPDATE_VULNERABILITY', payload: updatedVuln });
      } else {
        const newVuln = await createVulnerability(form);
        dispatch({ type: 'ADD_VULNERABILITY', payload: newVuln });
      }
      setForm(initialForm);
      setEditingId(null);
    } catch (err) {
      setError(editingId ? 'Failed to update vulnerability' : 'Failed to create vulnerability');
      console.error('Error submitting vulnerability:', err);
    }
  }

  async function handleDelete(vulnerability: Vulnerability) {
    if (!isAdmin) return;
    try {
      await deleteVulnerability(vulnerability.id);
      dispatch({ type: 'DELETE_VULNERABILITY', payload: vulnerability.id });
      setError('');
      await loadVulnerabilities();
    } catch (err) {
      setError('Failed to delete vulnerability');
      console.error('Error deleting vulnerability:', err);
    }
  }

  function handleEdit(vulnerability: Vulnerability) {
    if (!isAdmin) return;
    setForm({
      title: vulnerability.title,
      description: vulnerability.description,
      criticality: vulnerability.criticality,
      cwe: vulnerability.cwe,
      suggestedFix: vulnerability.suggestedFix || '',
      status: vulnerability.status,
    });
    setEditingId(vulnerability.id.toString());
  }

  async function handleStatusChange(vulnerability: Vulnerability, status: VulnerabilityState) {
    if (!isAdmin) return;
    try {
      const { id, ...vulnData } = vulnerability;
      const updatedVuln = await updateVulnerability(id.toString(), { ...vulnData, status });
      dispatch({ type: 'UPDATE_VULNERABILITY', payload: updatedVuln });
    } catch (err) {
      setError('Failed to update vulnerability status');
      console.error('Error updating vulnerability status:', err);
    }
  }

  return (
    <div>
      {error && <div className="error">{error}</div>}
      {(!editingId || isAdmin) && (
        <VulnerabilityForm
          form={form}
          onChange={handleChange}
          onSubmit={handleSubmit}
          editing={!!editingId}
          criticalityOptions={CRITICALITY_OPTIONS}
          onCancel={() => {
            setEditingId(null);
            setForm(initialForm);
          }}
        />
      )}
      <FiltersBar />
      {isLoading ? (
        <div className="loading">Loading vulnerabilities...</div>
      ) : (
        <VulnerabilityGrid
          vulnerabilities={filteredVulnerabilities}
          onEdit={isAdmin ? handleEdit : undefined}
          onDelete={isAdmin ? handleDelete : undefined}
          onStatusChange={isAdmin ? handleStatusChange : undefined}
          STATES={STATES}
        />
      )}
    </div>
  );
}
