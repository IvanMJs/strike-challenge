import React, { useEffect, useState } from 'react';
import VulnerabilityForm from '../components/vulnerabilityForm/VulnerabilityForm';
import VulnerabilityGrid from '../components/vulnerabilityGrid/VulnerabilityGrid';
import FiltersBar from '../components/filterBar/FiltersBar';
import { useAuth } from '../context/AuthContext';
import { useVulnerabilities } from '../context/VulnerabilityContext';
import { STATES, CRITICALITY_OPTIONS } from '../utils/constants';
import type { VulnerabilityState, VulnerabilityCriticality } from '../types/constants';
import type { Vulnerability, VulnerabilityCreate, VulnerabilityFormData, HistoryEntry } from '../types/vulnerability';
import { createVulnerability, deleteVulnerability, fetchVulnerabilities, updateVulnerability } from '../services/vulnerabilityService';

const initialForm: VulnerabilityFormData = {
  title: '',
  description: '',
  criticality: '',
  cwe: '',
  suggestedFix: '',
  status: '',
};

export function VulnerabilityView() {
  const { dispatch, filteredVulnerabilities } = useVulnerabilities();
  const { isAdmin } = useAuth();
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [form, setForm] = useState<VulnerabilityFormData>(initialForm);
  const [formKey, setFormKey] = useState(0);

  useEffect(() => {
    loadVulnerabilities();
  }, []);

  async function loadVulnerabilities() {
    setIsLoading(true);
    try {
      const vulns = await fetchVulnerabilities();
      dispatch({ type: 'SET_VULNERABILITIES', payload: vulns });
    } catch (err) {
      setError('Failed to fetch vulnerabilities');
      console.error('Error fetching vulnerabilities:', err);
    } finally {
      setIsLoading(false);
    }
  }
  function handleChange(e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) {
    const value = e.target.value;
    const name = e.target.name;
    
    setForm((prev: VulnerabilityFormData) => ({
      ...prev,
      [name]: value
    }));
  }

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError('');
    try {
      const submissionData: VulnerabilityCreate = {
        ...form,
        criticality: form.criticality as VulnerabilityCriticality,
        status: form.status as VulnerabilityState,
      };

      const newVuln = await createVulnerability(submissionData);
      dispatch({ type: 'ADD_VULNERABILITY', payload: newVuln });
      setForm(initialForm);
      setFormKey(prev => prev + 1);
    } catch (err) {      const errorMessage = err instanceof Error ? err.message : 'Failed to create vulnerability';
      setError(errorMessage);
      console.error('Error submitting vulnerability:', err);
    }
  }

  async function handleDelete(vulnerability: Vulnerability) {
    if (!isAdmin) return;
    try {
      await deleteVulnerability(vulnerability.id);
      dispatch({ type: 'DELETE_VULNERABILITY', payload: vulnerability.id });
      setError('');
    } catch (err) {
      setError('Failed to delete vulnerability');
      console.error('Error deleting vulnerability:', err);
    }
  }
  async function handleEdit(vulnerability: Vulnerability) {
    if (!isAdmin) return;
    try {
      // Ensure we're sending the complete vulnerability object with history
      const updatedVulnerability = {
        ...vulnerability,
        history: vulnerability.history || [],
        updatedAt: new Date().toISOString()
      };
      
      const response = await updateVulnerability(updatedVulnerability.id.toString(), updatedVulnerability);
      
      // Make sure we update the local state with the complete response
      dispatch({ type: 'UPDATE_VULNERABILITY', payload: response });
      setError('');
    } catch (err) {
      setError('Failed to update vulnerability');
      console.error('Error updating vulnerability:', err);
    }
  }
  async function handleStatusChange(vulnerability: Vulnerability, status: VulnerabilityState) {
    if (!isAdmin) return;
    try {
      const historyEntry: HistoryEntry = {
        at: new Date().toISOString(),
        changes: [{
          field: 'Status',
          from: vulnerability.status,
          to: status
        }]
      };      // Only send the fields that are changing
      const updatePayload = {
        status,
        history: [...(vulnerability.history || []), historyEntry]
      };
      
      const response = await updateVulnerability(vulnerability.id.toString(), updatePayload);
      dispatch({ type: 'UPDATE_VULNERABILITY', payload: response });
    } catch (err) {
      setError('Failed to update vulnerability status');
      console.error('Error updating vulnerability status:', err);
    }
  }

  return (
    <div>
      {error && <div className="error">{error}</div>}
      <VulnerabilityForm
        key={formKey}
        form={form}
        onChange={handleChange}
        onSubmit={handleSubmit}
        editing={false}
        criticalityOptions={CRITICALITY_OPTIONS}
        onCancel={() => {
          setForm(initialForm);
          setFormKey(prev => prev + 1);
        }}
      />
      <FiltersBar />
      {isLoading ? (
        <div className="loading">Loading vulnerabilities...</div>
      ) : (
        <VulnerabilityGrid
          vulnerabilities={filteredVulnerabilities}
          onEdit={isAdmin ? handleEdit : undefined}
          onDelete={isAdmin ? handleDelete : undefined}
          onStatusChange={isAdmin ? handleStatusChange : undefined}
          STATES={STATES}
        />
      )}
    </div>
  );
}
